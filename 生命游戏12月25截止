#include<iostream>
//Easy X
#include<graphics.h>
//这个库用来获取键盘
#include <conio.h>
//这个库用来实现多线程
#include<thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
std:: thread getAndSetThread;
std::mutex field_mutex;
std::condition_variable cv;
std::atomic_bool is_continue(true);
#define cube_size 20
#define side 40
//媒体播放
#include<mmsystem.h>
#pragma comment(lib,"winmm.lib")
using namespace std;
bool is_running;
//bool is_continue;
bool field[side][side];
bool ass[side][side];//用来记录一次演变后的细胞状态
//更新一个格子的细胞状态
int d_x[3] = { -1,0,1 };
int d_y[3] = { -1,0,1 };
bool update(int x, int y) {
	int sum = 0;//这里包括自己在内的9个格子
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++)
		{
			int dx = (x + d_x[i]);
			int dy = (y + d_y[j]);//遍历每一个周边的格子
			if (field[dx][dy]) {
				sum += 1;
			}
		}
	}
	if (field[x][y]==true) {
		if (sum < 3 || sum>4) { return false; }
		else { return true; }
	}
	else { if (sum == 3 ) { return  true; } else { return false; }
	}
}
//绘制地图
void drawmap() {
	setfillcolor(BLACK);
	for (int i = 0; i < side; i++) {
		for (int j = 0; j < side; j++) {
			if (field[i][j]) { fillrectangle(i * cube_size, j * cube_size, (i + 1) * cube_size, (j + 1) * cube_size); }
			else { clearrectangle(i * cube_size + 1, j * cube_size + 1, (i+1) * cube_size - 1, (j+1) * cube_size - 1); }
		//clear会连着边界绿线一起清理掉，故把边界向内缩一个像素
		}
	}
}
void evolve() {
	for (int i = 0; i < side; i++) {
		for (int j = 0; j < side; j++) {
			ass[i][j] = update(i, j);
		}
	}
	for (int i = 0; i < side; i++) {
		for (int j = 0; j < side; j++) {
			field[i][j] = ass[i][j];
		}
	}
}
//循环不断获取鼠标信息并根据鼠标信息设置map
void getAndSet(bool(&field)[side][side]) {
	MOUSEMSG msg;
	while (is_continue) {
		//获取鼠标信息
		msg = GetMouseMsg();
		//根据鼠标信息设置map
		if (msg.mkLButton) {//鼠标左键按下 设置为存活
			//输出每一次鼠标点击的坐标
			cout<<"\t x="<<msg.x/cube_size<<"\t y="<<msg.y/cube_size<<endl;
			if ((side - 1) == (msg.y / cube_size) &&
				(side - 1) == (msg.x / cube_size)) {//点击右下角那个点开始演化
				is_continue = false;
			//播放背景音乐，这里我选择卡农	
			mciSendString("open canno.MP3",NULL,NULL,NULL);
			mciSendString("play canno.mp3",NULL,NULL,NULL);
			}
			field[msg.x / cube_size][msg.y / cube_size] = true;
		}
		else if (msg.mkRButton) {//鼠标右键点击，设置为不存活
			field[msg.x / cube_size][msg.y / cube_size] = false;

		}
//这里注释掉drawmap函数是因为在主循环中不断画图已经足够，再增加这个就只会徒增功耗
		//drawmap();
	}
}
//封装一个函数，用来初始化界面
void initgame() {
	is_running = true;
	is_continue = true;
	initgraph(cube_size * side, cube_size * side);
	setbkcolor(WHITE);
	setlinecolor(GREEN);
	cleardevice();
	field[side][side] = false;
	ass[side][side] = false;
	for (int i = 0; i < side; i++) {
		line(i * cube_size, 0, i * cube_size, side * cube_size);
		line(0, i * cube_size, side * cube_size, i * cube_size);
	}
}
int main(){
		initagme();
//启动一个新的线程
		getAndSetThread = std::thread(getAndSet, std::ref(field));
		BeginBatchDraw();
	//主循环
	while (is_running) {
		//绘图部分
		Sleep(200);
		drawmap();
		//键鼠部分
		//getAndSet(field);
		//演化
		evolve();
//双缓冲，提高帧率
		FlushBatchDraw();
//多线程
		cv.notify_one();
//按Q/q键可以退出程序（表现为暂停演化）
if (_kbhit()) {
	char ch = _getch();
	if (ch == 'Q' || ch == 'q') {
		is_running = false;
		//关闭音乐
		mciSendString("close canno.mp3", NULL, NULL, NULL);
	}
}
	}
//并行函数getAndSet
getAndSet(field);
getAndSetThread.join();
EndBatchDraw();
	getchar();
	return 0;
}
