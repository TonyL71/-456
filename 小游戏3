#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#include<graphics.h>	//图形库
#include<mmsystem.h>
#include<iostream>
using namespace std;
#pragma comment(lib,"winmm.lib")
#define SIZE 40	//图片的尺寸
int ROWL=10;
int COLS=10;
int minenum=10;
//加载资源
IMAGE  imgs[12];
void loadImgs()
{
	for (int i = 0; i < 12; i++)
	{
		char buf[50] = { 0 };
		sprintf_s(buf, "./images/%d.jpg", i);
		loadimage(imgs + i, buf, SIZE, SIZE);
	}
}



/*定义一个地图*/
struct Map
{
	int** arr;	//二维数组指针
	int rows;	//行数
	int cols;	//列数
};
void map_recOpen(Map* map, int row, int col);
//初始化Map
void map_init(Map* map, int rows, int cols)
{
	map->rows = rows;
	map->cols = cols;
	map->arr = (int**)calloc(map->rows, sizeof(int*));
	if (!map->arr)
	{
		printf("内存申请失败\n");
		return;
	}
	for (int i = 0; i < map->rows; i++)
	{
		map->arr[i] = (int*)calloc(map->cols, sizeof(int));
		if (!map->arr[i])
		{
			printf("内存申请失败");
			return;
		}
	}
}
//输出一下所有的数据（控制台）
void map_show(Map* map)
{
	for (int i = 0; i < map->rows; i++)
	{
		for (int k = 0; k < map->cols; k++)
		{
			printf("%2d ", map->arr[i][k]);
		}
		printf("\n");
	}
}
//设置雷 -1,num 表示雷的数量
void map_setMine(Map* map, int num)
{
	//设置随机数种子
	srand(time(NULL));
	for (int i = 0; i < num; )
	{
		//随机产生下标	[0~10)
		int r = rand() % map->rows;
		int c = rand() % map->cols;
		if (map->arr[r][c] == 0)
		{
			//把指定的位置的值变为-1
			map->arr[r][c] = -1;
			i++;	//只有成功设置了雷，才自增
		}
	}

	//把以雷为中心的九宫格的数字都+1(雷除外)
	for (int i = 0; i < map->rows; i++)
	{
		for (int k = 0; k < map->cols; k++)
		{
			if (map->arr[i][k] == -1)
			{
				//遍历以雷为中心的九宫格
				for (int r = i - 1; r <= i + 1; r++)
				{
					for (int c = k - 1; c <= k + 1; c++)
					{
						//排除掉雷
						if ((r >= 0 && r < map->rows && c >= 0 && c < map->cols)
							&& map->arr[r][c] != -1)
						{
							map->arr[r][c] += 1;
						}
					}
				}
			}
		}
	}
}
//绘制界面(图形窗口上)
void map_draw(Map* map)
{
	for (int i = 0; i < map->rows; i++)
	{
		for (int k = 0; k < map->cols; k++)
		{
			//求每个格子左上角的坐标
			int x = k * SIZE;
			int y = i * SIZE;
			//判断是不是数字[0~8)
			if (map->arr[i][k] >= 0 && map->arr[i][k] <= 8)
			{
				putimage(x, y, imgs + map->arr[i][k]);
			}
			//如果是雷
			else if (map->arr[i][k] == -1)
			{
				putimage(x, y, imgs + 9);
			}
			//加密之后，最小的数字是多少 19 最大的是多少28
			else if (map->arr[i][k] >= 19 && map->arr[i][k] <= 28)
			{
				putimage(x, y, imgs + 10);
			}
			//如果是被标记，则贴图为小红旗
			else if (map->arr[i][k] >= 39)
			{
				putimage(x, y, imgs + 11);
			}
		}
	}
}
void allsweep(Map *map) {
	for (int i = 0; i < ROWL; i++) {
		for (int j = 0; j < COLS; j++) {
			map->arr[i][j] -= 20;
			map_draw(map);
		}
	}
}
//把每个格子盖起来
void map_cover(Map* map)
{
	//让现在数组里面的数据变得不一样-1 0~8
	for (int i = 0; i < map->rows; i++)
	{
		for (int k = 0; k < map->rows; k++)
		{
			map->arr[i][k] += 20;
		}
	}
}
//点几格子，然后打开
void map_mouseMsg(Map* map, ExMessage* msg)
{
	//根据鼠标坐标，获得点击的格子的下标
	int r = msg->y / SIZE;
	int c = msg->x / SIZE;
	//如果是鼠标左键点击，就打开格子
	if (msg->message == WM_LBUTTONDOWN && map->arr[r][c] >= 19 && map->arr[r][c])
	{
		PlaySound("./images/click.wav", NULL, SND_ASYNC | SND_FILENAME);
		map->arr[r][c] -= 20;
		if (map->arr[r][c] = -1) { allsweep(map); return; }
		map_recOpen(map, r, c);
		system("cls");
		map_show(map);
	}
	else if (msg->message == WM_RBUTTONDOWN && map->arr[r][c] >= 19 && map->arr[r][c] <= 28)
	{
		PlaySound("./images/click.wav", NULL, SND_ASYNC | SND_FILENAME);
		map->arr[r][c] += 20;
		map_show(map);
		system("cls");
	}
}
//如果点到空白格子，就递归打开周围的所有的空白格子和数字格子
void map_recOpen(Map* map, int row, int col)
{
	//先判断一下row col位置是不是空白格子
	if (map->arr[row][col] != 0)
		return;

	//遍历以这个空白格子为中心的九宫格
	for (int r = row - 1; r <= row + 1; r++)
	{
		for (int c = col - 1; c <= col + 1; c++)
		{
			//排除掉雷
			if ((r >= 0 && r < map->rows && c >= 0 && c < map->cols)
				&& map->arr[r][c] >= 19 && map->arr[r][c] <= 28)
			{
				map->arr[r][c] -= 20;
				map_recOpen(map, r, c);	//递归
			}
		}
	}
}

int main()
{
	//ROWL = 0;
	//COLS = 0;
	//int m = 0;
	//cout << "欢迎进入扫雷，你可以选择游戏难度：" << endl;
	//cout << "输入1为简单模式（10*10），有10个雷" << endl;
	//cout << "输入2为中等模式（30*20），有60个雷" << endl;
	//cout << "输入3为专家模式" << endl;
	//cin >> m;
	//switch (m) {
	//case 1:ROWL = 10, COLS = 10; minenum = 10;
	//case 2:ROWL = 30, COLS = 20; minenum = 60;
	////case 3:ROWL = 10, COLS = 10; minenum = 10;
	//}

	//创建图形窗口
	initgraph(ROWL*SIZE, COLS*SIZE, EW_SHOWCONSOLE);

	//播放背景音乐
	mciSendString("open ./images/start.mp3 alias bgm", NULL, 0, NULL);
	mciSendString("play bgm", NULL, 0, NULL);

	loadImgs();

	Map map;
	map_init(&map, ROWL, COLS);
	map_setMine(&map, minenum);
	map_cover(&map);
	//消息循环
	while (true)
	{
		ExMessage msg = { 0 };
		while (peekmessage(&msg, EM_MOUSE))
		{
			map_mouseMsg(&map, &msg);
		}

		map_draw(&map);
	}

	getchar();
	return 0;
}
